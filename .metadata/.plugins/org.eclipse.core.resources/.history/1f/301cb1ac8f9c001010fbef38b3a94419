
#include "Vbm.h"
#include <inttypes.h>
#include <stdio.h>
#include <string.h>// ✅ Ajout nécessaire pour memcpy
#include "Can.h"
#include "Can_bus.h"
void node_receive_Vbm(CAN_Message msg) {
    printf("  [Node] Received message ID: %03X, Data:", msg.id);
    for (int i = 0; i < msg.dlc; i++) {
        printf(" %02X", msg.data[i]);
    }
    printf("\n");
}

void node_send_Vbm(CAN_Bus *bus, unsigned int id, unsigned char *data, unsigned char len) {
    CAN_Message msg;
    msg.id = id;
    msg.dlc = len;
    memcpy(msg.data, data, len);
    can_bus_send(bus, msg);
}

// === Interfaces externes vers Vbm ===
/*void FumToVbmMsg(IdentEcu ident) {
	idents.Ident1.mh=ident.mh;
    trigs.Rx1Trig=true;
}
void FumIdToVbmMsg(IdentEcu ident) {
	idents.Ident1.mn=ident.mn;
	idents.Ident1.mt=ident.mt;
	trigs.RxId1Trig=true;
}*/
void LimToVbmMsg(IdentEcu ident) {
	idents.Ident2.mh=ident.mh;
    trigs.Rx2Trig=true;
}

void LimIdToVbmMsg(IdentEcu ident) {
	idents.Ident2.mn=ident.mn;
	idents.Ident2.mt=ident.mt;
}

void sendFumToVbmMsg(uint32_t mh){
	idents.Ident1.mh=mh;
    trigs.Rx1Trig=true;
}
void sendFumIdToVbmMsg(uint32_t mn, uint16_t mt){
	idents.Ident1.mn=mn;
	idents.Ident1.mt=mt;
	trigs.RxId1Trig=true;
}

// === Init === //
void VbmInit(){
	ident0.mn=10;
	ident0.mt=11;
	ident0.mh= 1000;
	VbmCounter=ident0.mh;

	idents.Ident1.mh=0xFFFFFFFF;
	idents.Ident1.mt=0xFFFF;
	idents.Ident1.mh=0xFFFFFFFF;

	idents.Ident2.mh=0xFFFFFFFF;
	idents.Ident2.mt=0xFFFF;
	idents.Ident2.mh=0xFFFFFFFF;

	phases.SyncConfigPhase=true; //en GeneratorOn
	phases.SyncDiagPhase=false; //en ReadyToStartEngine

	trigs.DiagTrig=true;
	trigs.TxTrig=false;

	configs.DiagTrigCfg=true;//force cfg après paramétrage
	configs.ParamCheckCfg=false;// accepte cfg si condition ok

	InitDho_Vbm(configs);
}

// === Fonction principale appelée toutes les 10 ms ===
void Vbm_step50ms() {
	compteurStep50ms++;
    if (compteurStep50ms % PERIOD_COUNT50ms_1s == 0){
    	VbmCounter++;
    	ident0.mh=VbmCounter;
    }

    if (phases.SyncConfigPhase){
        Call50msDho_Vbm(&trigs,&ident0,idents);
        if (trigs.TxTrig){
        	ReceiveVbmMsg(ident0.mh);//VbmToFumMsg(ident0);
        	VbmToLimMsg(ident0);
        	trigs.TxTrig = false;
        }
    }
    else if (phases.SyncDiagPhase){
        Call50msDho_Vbm_Diag(&trigs,&ident0,idents);
        if (trigs.TxTrig){
        	ReceiveVbmMsg(ident0.mh);//VbmToFumMsg(ident0);
        	VbmToLimMsg(ident0);
        	trigs.TxTrig = false;
        }
    }
    else if (0 == (compteurStep50ms %PERIOD_MSGID50ms_3s)){
    	ReceiveVbmMsg(ident0.mh);//VbmToFumMsg(ident0);
    	VbmToLimMsg(ident0);
    }
	VbmCounter=ident0.mh;
	if (0 == (compteurStep50ms %PERIOD_STORE50ms_5s)){
		Store(filename_Vbm,ident0.mn, ident0.mt, ident0.mh);
	}
	if (0 == (compteurStep50ms %PERIOD_MSGID50ms_5s)){
		ReceiveVbmIdMsg(ident0.mn,ident0.mt);//VbmIdToFumMsg(ident0);

    	printf("Debug Vbm : %" PRId32 "\n", ident0.mn);
		VbmIdToLimMsg(ident0);
	}
}

